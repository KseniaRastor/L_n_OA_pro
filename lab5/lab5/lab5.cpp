#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <locale.h>
#include <stdlib.h>
#include <time.h>


int main(void) {
	int n;				//размер матрицы
	int size_G = 0;		//переменная для подсчета размера графа G
	int col_one;		//переменная для подсчета количества единиц

	setlocale(0, "rus");
	printf("Введите размер матрицы -> ");
	scanf("%d", &n);		//польщоватлеь вводит размер матрицы
	printf("\n");


	/*Матрица смежности*/
	int** G = (int**)malloc(n * sizeof(int*));		//выделение памяти для двумерного массива - матрицы смежности неориентированного графа G
	for (int i = 0; i < n; i++) {
		G[i] = (int*)malloc(n * sizeof(int));
	}

	srand(time(0));										//граф неориентированный -> матрица симметричная
	for (int i = 0; i < n; i++) {						//формирование матирицы смежности
		for (int j = 0; j < n; j++) {
			if (j >= i) {								//генерируем только бласть матрицы над главной диагональю
				if (i == j) G[i][j] = 0;				//главная диагональ заполняется нулями (петель в вершинах нет)
				else {
					G[i][j] = rand() % 2;				//генерируется случайное значение [0;1]
					G[j][i] = G[i][j];					//значение дублируется симметрично относительно главной диагонали
				}												//т.е. заполняется область под главной диагональю
			}
		}
	}


	for (int i = 0; i < n; i++) {						//вывод матрицы и её размера
		for (int j = 0; j < n; j++) {
			printf(" %d", G[i][j]);
			if (G[i][j] == 1) size_G++;					//подсчет "1"			
		}
		printf("\n");
	}
	size_G = size_G / 2;								//размер графа = (количество "1")/2
	printf("\nРазмер графа = %d\n", size_G);


	for (int i = 0; i < n; i++) {						//поиск изолированных, концевых и доминирующих вершин
		col_one = 0;									//начало подсчета количества "1" для каждой строки матрицы
		for (int j = 0; j < n; j++) {
			if (G[i][j] == 1) col_one++;				//считаем кол-во "1"
		}

		if (col_one == 0) printf("Вершина %d изолировнная\n", i + 1);		//изолированная вершина - связей нет
		if (col_one == 1) printf("Вершина %d концевая\n", i + 1);			//концевая - только одна связь
		if (col_one == n - 1) printf("Вершина %d доминирующая\n", i + 1);	//доминирующая - смежна со всеми другими вершинами
	}
	printf("\n\n");



	/*Матрица инцидентности*/
	int j_int = 0;
	int** Gi = (int**)malloc(size_G * sizeof(int*));

	for (int i = 0; i < n; i++) {
		Gi[i] = (int*)malloc(n * sizeof(int));
	}


	for (int i = 0; i < n; i++) {				//формирование матрицы инцидентности
		for (int j = 0; j < n; j++) {
			if (j > i) {						//половина матрицы G
				if (G[i][j] == 1) {
					Gi[i][j_int] = 1;
					Gi[j][j_int] = 1;
					j_int++;
				}
			}
		}
	}

	for (int i = 0; i < n; i++) {				//вывод матрицы инцидентности и её размера
		for (int j = 0; j < size_G; j++) {
			if (Gi[i][j] != 1) Gi[i][j] = 0;
			printf(" %d", Gi[i][j]);
		}
		printf("\n");
	}
	printf("\nРазмер графа = %d\n", j_int);

	for (int i = 0; i < n; i++) {				//поиск изолированных, концевых и доминирующих вершин
		col_one = 0;
		for (int j = 0; j < size_G; j++) {
			if (Gi[i][j] == 1) col_one++;
		}

		if (col_one == 0) printf("Вершина %d изолировнная\n", i + 1);
		if (col_one == 1) printf("Вершина %d концевая\n", i + 1);
		if (col_one == n - 1) printf("Вершина %d доминирующая\n", i + 1);
	}


	return(0);
}
